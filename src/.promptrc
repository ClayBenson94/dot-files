#!/bin/bash
#$HOME/.promptrc

# Author: Casey DeLorme
# Created On: 12-30-2013
# Updated On: 01-25-2014
# Description: Entirely rewritten bash PS1 enhancer targeting git repositories, fully extendable
# License: GPLv3+

### Instructions!
# Toggle with Booleans:
#  Turn enhanced prompt off with `ENHANCED_PROMPT`
#  Turn git prompt on/off with `GIT_PROMPT_ON`
#  Only display branch name with `GIT_PROMPT_BRANCH_ONLY`
#  Turn detailed git prompt output on/off with `GIT_PROMPT_DETAILED`
#
#   These variables can be defined in your bashrc for semi-permanent functionality.
#
# Extend with Array (called at tail of prompt output):
#  ENHANCERS+=('newFunctionName')
#

# Define color functions for enhanced terminal aesthetics
c_bold=`tput bold`
c_red=`tput setaf 1`
c_green=`tput setaf 2`
c_blue=`tput setaf 4`
c_purple=`tput setaf 5`
c_cyan=`tput setaf 6`
c_sgr0=`tput sgr0`

# Define enhancers for easy future-external customization
export ENHANCERS=('gitify')

# Add git information if applicable
gitify ()
{

    # Check GIT_PROMPT_ON before running git status check
    if $GIT_PROMPT_ON
    then

        # Grab the branch
        git_branch=$(git branch | grep -e "^\*\s" | tr -d '* ')

        # If no error occurred assume we are inside a repo
        if [ $? -eq 0 ]
        then

            if $GIT_PROMPT_BRANCH_ONLY
            then

                # Append branch only
                prompt_string="${prompt_string} [${git_branch}]"

            else

                # Acquire git status
                git_stats=$(git status --porcelain --untracked-files=all)

                # Get count of changes from git_stats
                git_changes=$(echo "${git_stats}" | wc -l | tr -d ' ')

                # If no changes print branch only
                if [ $git_changes -gt 0 ]
                then

                    # Append branch with red color to prompt string
                    prompt_string="${prompt_string} [${c_red}${git_branch}${c_sgr0}: "

                    # Do we need detailed output?
                    if $GIT_PROMPT_DETAILED
                    then

                        # Currently this script only attends to:
                        #   new files
                        #   modified files
                        #   deleted filesd
                        #   untracked files
                        # it will not count anything it cannot identify
                        # it will not show branch conflicts (eg both*)
                        # it **will** show unstaged and staged independently (if both exist)
                        #  Format: u#,m#/#,d#/#

                        # Set a default of 0 for expected items
                        modified_unstaged_count=0
                        deleted_unstaged_count=0
                        modified_staged_count=0
                        deleted_staged_count=0
                        untracked_count=0

                        # Parse known types for detailed output
                        untracked_count=$(echo "${git_stats}" | grep -c "??")
                        modified_staged_count=$(echo "${git_stats}" | grep -c "")
                        modified_unstaged_count=$(echo "${git_stats}" | grep -c "")
                        deleted_staged_count=$(echo "${git_stats}" | grep -c "")
                        deleted_unstaged_count=$(echo "${git_stats}" | grep -c "")

                        # Append Detailed Output Logically
                        # This is as clean as I could make this quickly
                        # There may be a fancier way to approach printing
                        # these values conditionally...

                        # If we have untracked items, append
                        [[ $untracked_count -gt 0 ]] && prompt_string="${prompt_string}${c_red}u${untracked_count}${c_sgr0}"

                        # If we have unstaged modified append
                        [[ $modified_unstaged_count -gt 0 ]] && prompt_string="${prompt_string}${c_red}m${modified_unstaged_count}${c_sgr0}" && [[ $modified_staged_count -gt 0 ]] && prompt_string="${prompt_string}/"

                        # If we have staged modified append green
                        [[ $modified_staged_count -gt 0 ]] && prompt_string="${prompt_string}${c_green}${modified_staged_count}${c_sgr0}"

                        # If we have unstaged deleted append
                        [[ $deleted_unstaged_count -gt 0 ]] && prompt_string="${prompt_string}${c_red}d${deleted_unstaged_count}${c_sgr0}" && [[ $deleted_staged_count -gt 0 ]] && prompt_string="${prompt_string}/"

                        # If we have staged deleted append green
                        [[ $deleted_staged_count -gt 0 ]] && prompt_string="${prompt_string}${c_green}${deleted_staged_count}${c_sgr0}"

                        # Close prompt
                        prompt_string="${prompt_string}]"

                    else

                        # Append count & close branch
                        prompt_string="${prompt_string}${c_red}${git_changes}${c_sgr0}]"
                    fi
                else
                    prompt_string="${prompt_string} [${c_green}${git_branch}${c_sgr0}]"
                fi
            fi
        fi
    fi
}

# Create a colorful detailed prompt
colorify ()
{
    # Confirm enhanced prompt
    if $ENHANCED_PROMPT
    then

        # If Linux display milliseconds (OSX does not support %N `data`)
        if [ $(uname) = "Darwin" ]
        then
            prompt_string="${c_blue}${0} ($(date +'%R:%S')) ${c_purple}$(whoami)${c_sgr0}@${c_green}$(hostname) ${c_bold}${c_blue}$(dirs)${c_sgr0}"
        else
            prompt_string="${c_blue}${0} ($(date +'%R:%S.%3N')) ${c_purple}$(whoami)${c_sgr0}@${c_green}$(hostname) ${c_bold}${c_blue}$(dirs)${c_sgr0}"
        fi

        # Run through Enhancers
        for ENHANCEMENT in ${ENHANCERS[*]}
        do
            [[ $(type -t $ENHANCEMENT) = 'function' ]] && $ENHANCEMENT
        done

        # Output custom prompt
        echo -ne "\n${prompt_string}"

        # Start prompt on new line
        echo -ne "\n$ "
    else

        # Reset prompt to the original if it was ever modified
        [[ -n "${PSORIG}" ]] && PS1=${PSORIG}
    fi
}

# Grab the original
PSORIG=${PS1}

# By wrapping in single quotes we allow the command execution to be parsed only when requested
PS1='$(colorify)'

# When entering multi-line commands our prompt will be more sensible
PS2='continue-> '
