#!/bin/bash

# If clear exists, use it before we populate the screen with install messages
if which clear &> /dev/null
then
    clear
fi

# Give the user 5 seconds to cancel
echo "Preparing to install, cancel within 5 seconds via ctrl+c, or wait until the script finishes."
sleep 5

# get script info
if [ $(uname) = "Darwin" ]
then
    SELF=$(cd $(dirname "$0") && pwd -P)/$(basename "$0")
else
    SELF=$(readlink -f "$0")
fi
SELF_PATH=$(dirname "$SELF")

# redirect output to a logfile for the duration of this script
exec &> >(tee "${SELF}.log")

# define downloads & tmp file paths
DOWNLOADS="$SELF_PATH/downloads"
TMP_FILES="$DOWNLOADS/tmp"

# check for wget or curl to download all files
if which curl &> /dev/null
then
    DL_CMD="curl -L -o"
elif which wget &> /dev/null
then
    DL_CMD="wget -O"
    echo "curl package recommended..."
fi

# create dependent folders
mkdir -p "$DOWNLOADS/.vim/undo"
mkdir -p "$DOWNLOADS/.vim/colors"
mkdir -p "$TMP_FILES"

# check for git
if which git &> /dev/null
then

    # echo status
    echo "cloning vim plugin repositories..."

    # check for src/
    if [ ! -d "$SELF_PATH/src/" ]
    then

        # clone our own repo to grab the files
        git clone "https://github.com/cdelorme/dot-files" "$TMP_FILES/dot-files"
    fi

    # clone all repositories
    git clone "https://github.com/tpope/vim-vividchalk" "$TMP_FILES/vividchalk"
    git clone "https://github.com/tangphillip/SunburstVIM.git" "$TMP_FILES/sunburst"
    git clone "https://github.com/tristen/vim-sparkup" "$TMP_FILES/sparkup"
    git clone "https://github.com/Lokaltog/vim-easymotion" "$TMP_FILES/easymotion"
    git clone "https://github.com/tpope/vim-surround" "$TMP_FILES/surround"
    git clone "https://github.com/kien/ctrlp.vim" "$TMP_FILES/ctrlp"
    git clone "https://github.com/mattn/emmet-vim.git" "$TMP_FILES/emmet"
elif [ -n "$DL_CMD" ]
then

    # echo status
    echo "downloading vim plugins..."

    # download colorschemes directly
    $DL_CMD "$DOWNLOADS/.vim/colors/vividchalk.vim" "https://raw.github.com/tpope/vim-vividchalk/master/colors/vividchalk.vim"
    $DL_CMD "$DOWNLOADS/.vim/colors/sunburst.vim" "https://raw2.github.com/tangphillip/SunburstVIM/master/colors/sunburst.vim"

    if which unzip &> /dev/null
    then

        # download the zipped packages
        $DL_CMD "$TMP_FILES/sparkup.zip" "https://github.com/tristen/vim-sparkup/archive/master.zip"
        $DL_CMD "$TMP_FILES/easymotion.zip" "https://github.com/Lokaltog/vim-easymotion/archive/master.zip"
        $DL_CMD "$TMP_FILES/surround.zip" "https://github.com/tpope/vim-surround/archive/master.zip"
        $DL_CMD "$TMP_FILES/ctrlp.zip" "https://github.com/kien/ctrlp.vim/archive/master.zip"
        $DL_CMD "$TMP_FILES/emmet.zip" "https://github.com/tangphillip/SunburstVIM/archive/master.zip"

        # download our own repo if no src/
        if [ ! -d "$SELF_PATH/src/" ]
        then
            $DL_CMD "$TMP_FILES/dot-files.zip" "https://github.com/cdelorme/dot-files/archive/master.zip"
        fi

        # user feedback
        echo "decompressing packages..."

        # decompress packages and delete the zips
        for ZIP in "$TMP_FILES/"*.zip
        do
            unzip -q -o -d "${TMP_FILES}" "${ZIP}"
            rm -rf $ZIP
        done
    else
        echo "unzip required to install compressed contents..."
    fi
fi

# iterate all files in $TMP_FILES
for TMP_PATH in $TMP_FILES/*
do

    # Get a count of items
    CONTENTS=($TMP_PATH/*)

    # if not git, and only one item append to TMP_PATH to dig deeper
    if [ ! -d $TMP_PATH/.git ] && [ ${#CONTENTS[*]} -eq 1 ] && [ -d "$CONTENTS" ]
    then
        TMP_PATH="$TMP_PATH/$CONTENTS"
    fi

    # look for src directory
    if [ -d "$TMP_PATH/src" ]
    then

        # copy contents to downloads
        shopt -s dotglob
        cp -R "$TMP_PATH/src/"* "$DOWNLOADS"
        shopt -u dotglob
    else

        # iterate the contents
        for TMP_DIR in "$TMP_PATH/"*
        do

            # delete anything that is not a directory (readmes etc)
            if [ ! -d "$TMP_DIR" ]
            then
                rm -rf "$TMP_DIR"
            fi
        done

        # merge directories recursively with $DOWNLOADS/.vim/
        cp -Rf "$TMP_PATH/"* "$DOWNLOADS/.vim/"
    fi
done

# remove TMP_FILES path
rm -rf $TMP_FILES

# check for manual downloads (easier this way)
if [ -n "$DL_CMD" ]
then
    $DL_CMD "$DOWNLOADS/.git-completion" "https://raw2.github.com/git/git/master/contrib/completion/git-completion.bash"
    $DL_CMD "$DOWNLOADS/.githelpers" "https://raw2.github.com/garybernhardt/dotfiles/master/.githelpers"
fi

# if /src exists copy it to downloads else begin downloading the files from github
if [ -d "$SELF_PATH/src/" ]
then
    shopt -s dotglob
    cp -R "$SELF_PATH/src/"* "$DOWNLOADS"
    shopt -u dotglob
fi

if [ -d "$DOWNLOADS/.ssh" ]
then

    # custom argument parsing if at least a username ($1) was supplied
    if [ -n "$DL_CMD" ] && [ -n "$1" ]
    then

        # check for github password ($2) and the user is not root
        if [ -n "$2" ] && [ $(id -u) -ne 0 ]
        then

            # does a key already exist
            if ! [ -f "$HOME/.ssh/id_rsa" ]
            then

                # use user password ($3) or fallback to github password ($2)
                PASSWORD="$2"
                if [ -n "$3" ]
                then
                    PASSWORD="$3"
                fi

                # generate key
                ssh-keygen -q -b 4096 -t rsa -N "$PASSWORD" -f "$DOWNLOADS/.ssh/id_rsa"

                # add public key to trusted list on github
                HOST=$(hostname -s)
                DATE=$(date '+%Y/%m/%d')

                # attempt to push the key to github
                curl -i -u "${1}:${2}" -H "Content-Type: application/json" -H "Accept: application/json" -X POST -d "{\"title\":\"${HOST} (${DATE})\",\"key\":\"$(cat $DOWNLOADS/.ssh/id_rsa.pub)\"}" https://api.github.com/user/keys
            fi

            # if darwin prep homebrew api key and to append to .bashrc
            if [ $(uname) = "Darwin" ]
            then

                # Request keys from github
                keys=$(curl -s -i -u "${1}:${2}" -H "Content-Type: application/json" -H "Accept: application/json" -X GET https://api.github.com/authorizations)
                if echo $keys | grep "homebrew" &> /dev/null
                then
                    token=$(echo "${keys#*homebrew}" | grep token | head -n1 | tr -d '":,' | awk '{print $2}')
                else
                    keys=$(curl -i -u "${1}:${2}" -H "Content-Type: application/json" -H "Accept: application/json" -X POST -d "{\"scopes\":[\"gist\",\"repo\",\"user\"],\"note\":\"homebrew\"}" https://api.github.com/authorizations)
                    token=$(echo "$keys" | grep token | head -n1 | tr -d '":,' | awk '{print $2}')
                fi

                if [ -n "$token" ]
                then

                    # push token into .bashrc
                    echo -ne "\n# homebrew github token (remove rate-limiting)\nexport HOMEBREW_GITHUB_API_TOKEN=${token}" >> "$DOWNLOADS/.bash_profile"
                fi
            fi
        fi

        $DL_CMD "$DOWNLOADS/.ssh/authorized_keys" "https://github.com/${1}.keys"
    fi

    # set 0600 on the contents for ssh "strict-mode" compatibility
    chmod 0600 "$DOWNLOADS/.ssh/"*

    # set 0700 on $HOME/.ssh so we can still access its contents
    chmod 0700 "$DOWNLOADS/.ssh"
fi

# echo Status
echo "installing dot files..."

# install the files to home
shopt -s dotglob
cp -Rf "$DOWNLOADS/"* "$HOME"
shopt -u dotglob

# also try to install them to /etc/skel if the path exists & adjust .ssh permissions
if [ -d "/etc/skel" ]
then
    shopt -s dotglob
    cp -Rf "$DOWNLOADS/"* "/etc/skel"
    shopt -u dotglob
fi

# final status message
echo "dot files are installed."
